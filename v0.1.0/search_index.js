var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#predict","page":"API","title":"predict","text":"","category":"section"},{"location":"api/#Boltz1.predict","page":"API","title":"Boltz1.predict","text":"predict(input, [output_type]; options...)\n\nRun Boltz-1 prediction with the given input, output type, and options.\n\nInput types\n\nAbstractString: Path to a FASTA/YAML file or directory (for batching).\nMolecularInput: A single Boltz1.Schema.MolecularInput object.\nVector{MolecularInput}: A vector of Boltz1.Schema.MolecularInput objects for batching.\n\nOutput types\n\nBy default, raw results will be written to disk in the out_dir directory (see options).\n\nFor convenience, output_type can be provided as a second argument to reduce manual file I/O.\n\nIf output_type is provided, the function will return a single object if a MolecularInput was provided as input, otherwise a vector if an AbstractString or Vector{MolecularInput} was provided.\n\nThe following output types are supported:\n\nBioStructures.MolecularStructure: a rich and robust representation of molecular structures.\nProteinChains.ProteinStructure: a flat and specialized representation of protein structures for convenience.\n\nOptions\n\nNumeric Options\n\ndevices::Integer: Number of devices to use. Default: 1.\nrecycling_steps::Integer: Number of recycling steps. Default: 3.\nsampling_steps::Integer: Number of sampling steps. Default: 200.\ndiffusion_samples::Integer: Number of diffusion samples. Default: 1.\nstep_scale::Float64: Step size related to temperature. Default: 1.638.\nnum_workers::Integer: Number of dataloader workers. Default: 2.\nseed::Integer: RNG seed; default: none.\n\nString Options\n\nout_dir::String: The path where to save the predictions.\ncache::String: The directory where to download the data and model.\n\nDefaults to a Scratch.jl-backed directory created at module init; call clear_cache() to reset it.\n\ncheckpoint::String: Optional checkpoint path; defaults to Boltz-1 model.\naccelerator::String: 'gpu', 'cpu', or 'tpu'. Default: 'gpu'.\noutput_format::String: 'pdb' or 'mmcif'. Default: 'mmcif'.\nmsa_server_url::String: MSA server URL; requires use_msa_server=true.\nmsa_pairing_strategy::String: 'greedy' or 'complete'; requires use_msa_server=true.\n\nBoolean Flags\n\nverbose::Bool: Whether to print boltz logs to stdout. Default: true.\nwrite_full_pae::Bool: Dump PAE to a npz file. Default: true.\nwrite_full_pde::Bool: Dump PDE to a npz file. Default: false.\noverride::Bool: Override existing predictions. Default: false.\nuse_msa_server::Bool: Use MMSeqs2 server for MSA generation. Default: false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schema-submodule","page":"API","title":"Schema submodule","text":"","category":"section"},{"location":"api/#Boltz1.Schema.MolecularInput","page":"API","title":"Boltz1.Schema.MolecularInput","text":"MolecularInput\n\nA dictionary object that can be written to a YAML file.\n\nImplemented according to the schema definition in the boltz documentation, allowing for easy in-memory construction of the schema.\n\nSequences passed to protein, dna, and rna get automatically converted to strings, so any type (e.g. BioSequences.BioSequence) that has sensible Base.string-conversion defined will work.\n\nOne addition is that msa can be provided as a vector of strings.\n\nExamples\n\nLigand\n\nusing Boltz1.Schema\n\ninput1 = MolecularInput(\n    sequences = [\n        protein(\n            id = [\"A\", \"B\"],\n            sequence = seq,\n            msa = [seq, other...] # or path to a3m file\n        ),\n        ligand(\n            id = [\"C\", \"D\"],\n            ccd = \"SAH\"\n        ),\n        ligand(\n            id = [\"E\", \"F\"],\n            smiles = \"N[C@@H](Cc1ccc(O)cc1)C(=O)O\"\n        )\n    ]\n)\n\ninput2 = MolecularInput(\n    sequences = [\n        protein(\n            id = [\"A1\"],\n            sequence = seq\n        ),\n        ligand(\n            id = [\"B1\"],\n            ccd = \"EKY\"\n        )\n    ],\n    constraints = [\n        pocket(\n            binder = \"B1\",\n            contacts = [ [\"B1\", 1], [\"A1\", 138] ]\n        )\n    ]\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following sequence types go into the sequences vector keyword argument of MolecularInput.","category":"page"},{"location":"api/#Boltz1.Schema.protein","page":"API","title":"Boltz1.Schema.protein","text":"protein(; id, sequence, msa=nothing, modifications=nothing, cyclic=nothing)\n\nusing Boltz1.Schema: protein\nprotein(id=\"A\", sequence=\"RHKDE\")\nprotein(id=[\"A\", \"B\"], sequence=\"RHKDE\")\nprotein(id=\"A\", sequence=\"RHKDE\", msa=\"path/to/msa.a3m\")\nprotein(id=\"A\", sequence=\"RHKDE\", msa=[\"RHKDE\", \"RHKDE\"])\nprotein(id=\"A\", sequence=\"RHKDE\", modifications=[(1, \"MSE\"), (5, \"MSE\")])\nprotein(id=\"A\", sequence=\"RHKDE\", cyclic=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Boltz1.Schema.dna","page":"API","title":"Boltz1.Schema.dna","text":"dna(; id, sequence)\n\nusing Boltz1.Schema: dna\ndna(id=\"A\", sequence=\"GATTACA\")\ndna(id=[\"A\", \"B\"], sequence=\"GATTACA\")\ndna(id=\"A\", sequence=\"GATTACA\", modifications=[(2, \"6MA\"), (6, \"5MC\")]) # untested\ndna(id=\"A\", sequence=\"GATTACA\", cyclic=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Boltz1.Schema.rna","page":"API","title":"Boltz1.Schema.rna","text":"rna(; id, sequence)\n\nusing Boltz1.Schema: rna\nrna(id=\"A\", sequence=\"GAUUACA\")\nrna(id=[\"A\", \"B\"], sequence=\"GAUUACA\")\nrna(id=\"A\", sequence=\"GAUUACA\", modifications=[(2, \"I\"), (3, \"PSU\")]) # untested\nrna(id=\"A\", sequence=\"GAUUACA\", cyclic=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Boltz1.Schema.ligand","page":"API","title":"Boltz1.Schema.ligand","text":"ligand(; id, smiles=nothing, ccd=nothing)\n\nusing Boltz1.Schema: ligand\nligand(id=\"C\", smiles=\"C1=CC=CC=C1\")\nligand(id=[\"D\", \"E\"], ccd=\"SAH\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Constraints","page":"API","title":"Constraints","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following constraint types go into the constraints vector keyword argument of MolecularInput.","category":"page"},{"location":"api/#Boltz1.Schema.bond","page":"API","title":"Boltz1.Schema.bond","text":"bond(; atom1, atom2)\n\nusing Boltz1.Schema: bond\n# atom1 and atom2 are tuples of (chain_id, residue_index, atom_name)\nbond(atom1=(\"A\", 1, \"CA\"), atom2=(\"B\", 2, \"CA\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Boltz1.Schema.pocket","page":"API","title":"Boltz1.Schema.pocket","text":"pocket(; binder, contacts)\n\nusing Boltz1.Schema: pocket\n# binder is a chain_id\n# contacts is a vector of vectors of (chain_id, residue_index)\npocket(binder=\"A\", contacts=[[\"B\", 1], [\"C\", 2]])\n\n\n\n\n\n","category":"function"},{"location":"#Boltz1","page":"Home","title":"Boltz1","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Boltz1.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add Boltz1\"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"api.md\"\n]","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
